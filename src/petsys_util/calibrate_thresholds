#!/usr/bin/env python
# -*- coding: utf-8 -*-

from petsys import daqd, config
from copy import deepcopy
import argparse
from time import sleep
import ROOT
from sys import stdout

parser = argparse.ArgumentParser(description='Acquire data for TDC calibration')
parser.add_argument("--config", type=str, required=True, help="Configuration file")
parser.add_argument("-o", type=str, dest="outFileName", required=True, help="Output table file name")
parser.add_argument("--root-file", dest="rootFileName", help="Output ROOT file name")
args = parser.parse_args()


rootFile = None
if args.rootFileName:
	rootFile = ROOT.TFile(args.rootFileName, "RECREATE")


systemConfig = config.ConfigFromFile(args.config, loadMask=config.LOAD_AD5535_CALIBRATION | config.LOAD_SIPM_BIAS)
daqd = daqd.Connection()
daqd.initializeSystem()
systemConfig.loadToHardware(daqd, config.APPLY_BIAS_PREBD)
asicsConfig = daqd.getAsicsConfig()

COUNTER_SETTING = 0x4
COUNT_MAX = 1.0 * (2**22)
N_READS = 4
T = COUNT_MAX * 6.25E-9


thresholdList = [ 
	(0,  "vth_t1", "baseline_t" ),
	(1,  "vth_t2", "baseline_t" ),
	(2,  "vth_e", "baseline_e")
]

activeAsics = daqd.getActiveAsics()
activeChannels = [ (portID, slaveID, chipID, channelID) for channelID in range(64) for portID, slaveID, chipID in activeAsics ]

# Adjust baseline

for ac in asicsConfig.values():
	if not ac: continue
	gc = ac.globalConfig
	gc.setValue("counter_period", COUNTER_SETTING)
	for cc in ac.channelConfig:
		cc.setValue("trigger_mode_1", 0)
		cc.setValue("counter_mode", 0xF)
		cc.setValue("trigger_b_latched", 0)

print "Adjusting baseline"
for n, thresholdName, baselineName in thresholdList:
	print n, thresholdName, baselineName

	N_ITERATIONS = 0
	while N_ITERATIONS < 20:
		print baselineName, "ITERATION %d" % N_ITERATIONS

		for ac in asicsConfig.values():
			for cc in ac.channelConfig:
				cc.setValue("vth_t1", 0)
				cc.setValue("vth_t2", 0)
				cc.setValue("vth_e", 0)
				cc.setValue("trigger_mode_2_b", n)
				cc.setValue(thresholdName, 61)
		daqd.setAsicsConfig(asicsConfig)
		sleep(9 * T)

		count_high = {}
		for portID, slaveID, chipID, channelID in activeChannels:
			count_high[(portID, slaveID, chipID, channelID)] = daqd.readFEBDConfig(portID, slaveID, 3, 64*chipID + channelID) / COUNT_MAX


		adjustmentMade = False
		for portID, slaveID, chipID, channelID in activeChannels:
			b = asicsConfig[(portID, slaveID, chipID)].channelConfig[channelID].getValue(baselineName)
			channelOK = True
			if count_high[(portID, slaveID, chipID, channelID)] < 0.95:
				channelOK = False
				if b > 0:
					new_b = b - 1
					adjustmentMade = True
				else:	
					new_b = b

			else:
				new_b = b
			
			asicsConfig[(portID, slaveID, chipID)].channelConfig[channelID].setValue(baselineName, new_b)

			if not channelOK:
				print "Channel (%2d %2d %2d %2d) | %6.1f%% active | %2d -> %2d" % (portID, slaveID, chipID, channelID, 100.0*count_high[(portID, slaveID, chipID, channelID)], b, new_b)


		N_ITERATIONS += 1
		if not adjustmentMade: break


#
# Measure noise/baseline
# 
print "Scanning threshold for noise"
noiseProfiles = {}
for n, thresholdName, baselineName in thresholdList:
	stdout.write("%6s " % thresholdName); stdout.flush()
	for portID, slaveID, chipID, channelID in activeChannels:
		noiseProfiles[(portID, slaveID, chipID, channelID, thresholdName)] = ROOT.TProfile("hNoise_%02d_%02d_%02d_%02d_%s" % (portID, slaveID, chipID, channelID, thresholdName), "Noise", 64, 0, 64)

	for thresholdValue in range(0,64):
		for ac in asicsConfig.values():
			for cc in ac.channelConfig:
				cc.setValue("vth_t1", 0)
				cc.setValue("vth_t2", 0)
				cc.setValue("vth_e", 0)
				cc.setValue("trigger_mode_2_b", n)
				cc.setValue(thresholdName, thresholdValue)

		daqd.setAsicsConfig(asicsConfig)
		for n in range(N_READS):
			sleep(9 * T)
			for portID, slaveID, chipID, channelID in activeChannels:
				v = daqd.readFEBDConfig(portID, slaveID, 3, 64*chipID + channelID) / COUNT_MAX
				noiseProfiles[(portID, slaveID, chipID, channelID, thresholdName)].Fill(thresholdValue, v)

		stdout.write(".")
		stdout.flush()
		
	stdout.write("\n")

#
# Measure dark counts
# 
for ac in asicsConfig.values():
	if not ac: continue
	gc = ac.globalConfig
	gc.setValue("counter_period", COUNTER_SETTING)
	for cc in ac.channelConfig:
		cc.setValue("trigger_mode_1", 0)
		cc.setValue("counter_mode", 0xC)
		cc.setValue("trigger_b_latched", 0)
		cc.setValue("dead_time", 20)

systemConfig.loadToHardware(daqd, config.APPLY_BIAS_ON)
darkProfiles = {}
print "Scanning threshold for dark counts"
for n, thresholdName, baselineName in thresholdList:
	stdout.write("%6s " % thresholdName); stdout.flush()
	for portID, slaveID, chipID, channelID in activeChannels:
		darkProfiles[(portID, slaveID, chipID, channelID, thresholdName)] = ROOT.TProfile("hDark_%02d_%02d_%02d_%02d_%s" % (portID, slaveID, chipID, channelID, thresholdName), "Dark counts", 64, 0, 64)

	for thresholdValue in range(64):
		for ac in asicsConfig.values():
			for cc in ac.channelConfig:
				cc.setValue("vth_t1", 0)
				cc.setValue("vth_t2", 0)
				cc.setValue("vth_e", 0)
				cc.setValue("trigger_mode_2_b", n)
				cc.setValue(thresholdName, thresholdValue)

		daqd.setAsicsConfig(asicsConfig)
		for n in range(N_READS):
			sleep(9 * T)
			for portID, slaveID, chipID, channelID in activeChannels:
				v = daqd.readFEBDConfig(portID, slaveID, 3, 64*chipID + channelID) / T
				darkProfiles[(portID, slaveID, chipID, channelID, thresholdName)].Fill(thresholdValue, v)
				
		stdout.write(".")
		stdout.flush()
	stdout.write("\n")
	
systemConfig.loadToHardware(daqd, config.APPLY_BIAS_OFF)

fSigmoid = ROOT.TF1("fSigmoid","[0]*ROOT::Math::normal_cdf(x,[1],[2])",0,64);
fSigmoid.SetParName(0, "C")
fSigmoid.SetParName(1, "#sigma")
fSigmoid.SetParName(2, "x0")

fSigmoid.SetNpx(64)

for profile in noiseProfiles.values():
	low = profile.GetBinCenter(profile.FindFirstBinAbove(0.1) - 1)
	high = profile.GetBinCenter(profile.FindFirstBinAbove(0.9))
	fSigmoid.FixParameter(0, 1.0);
	fSigmoid.SetParameter(1, high-low);
	fSigmoid.SetParLimits(1, (high-low)/12, high-low)
	fSigmoid.SetParameter(2, (low+high)/2.0)
	fSigmoid.SetParLimits(2, low, high)
	profile.Fit("fSigmoid", "", "", 0, 64);
	
	
outFile = open(args.outFileName, "w")
outFile.write("# Port ID\tSlaveID\tChipID\tChannelID\tbaseline_T\tzero_T1\tnoise_T1\tzero_T2\tnoise_T2\tbaseline_E\tzero_E\tnoise_E\n")
for portID, slaveID, chipID, channelID in activeChannels:
	baseline_T = asicsConfig[(portID, slaveID, chipID)].channelConfig[channelID].getValue("baseline_t")
	baseline_E = asicsConfig[(portID, slaveID, chipID)].channelConfig[channelID].getValue("baseline_e")
	
	p = noiseProfiles[(portID, slaveID, chipID, channelID, "vth_t1")]
	f = p.GetFunction("fSigmoid")
	if f:
		zero_T1 = f.GetParameter(2)
		noise_T1 = f.GetParameter(1)
	else:
		print "WARNING: No fit for (%2d %2d %2d %2d %s)" % (portID, slaveID, chipID, channelID, "vth_t1")
		zero_T1 = 63.0
		noise_T1 = 10.0
	
	p = noiseProfiles[(portID, slaveID, chipID, channelID, "vth_t2")]
	f = p.GetFunction("fSigmoid")
	if f:
		zero_T2 = f.GetParameter(2)
		noise_T2 = f.GetParameter(1)
	else:
		print "WARNING: No fit for (%2d %2d %2d %2d %s)" % (portID, slaveID, chipID, channelID, "vth_t2")
		zero_T2 = 63.0
		noise_T2 = 10.0
	
	# WARNING: Scan is not working well for vth_E
	zero_E = 63.0
	noise_E = 10.0
	
	outFile.write("%d\t%d\t%d\t%d\t%d\t%f\t%f\t%f\t%f\t%d\t%f\t%f\n" % (
		 portID, slaveID, chipID, channelID,
		 baseline_T, zero_T1, noise_T1, zero_T2, noise_T2,
		 baseline_E, zero_E, noise_E))


if rootFile is not None:
	rootFile.Write()
	rootFile.Close()